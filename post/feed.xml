<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 轮子们</title>
    <link>http://blog.ywheel.cn/post/</link>
    <description>Recent content in Posts on 轮子们</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2016. All rights reserved.</copyright>
    <lastBuildDate>Sun, 29 May 2016 21:31:44 +0800</lastBuildDate>
    <atom:link href="http://blog.ywheel.cn/post/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>HUE Introduction and Contribution</title>
      <link>http://blog.ywheel.cn/post/2016/05/29/hue_introduction/</link>
      <pubDate>Sun, 29 May 2016 21:31:44 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2016/05/29/hue_introduction/</guid>
      <description>

&lt;p&gt;前段时间给同事们做了一次HUE入门使用的培训，就顺便整理出来。本篇文章先简单介绍HUE，再介绍如何给HUE贡献代码。&lt;/p&gt;

&lt;h2 id=&#34;hue是什么:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;HUE是什么&lt;/h2&gt;

&lt;p&gt;HUE=&lt;strong&gt;Hadoop User Experience&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hue是一个开源的Apache Hadoop UI系统，由Cloudera Desktop演化而来，最后Cloudera公司将其贡献给Apache基金会的Hadoop社区，它是基于Python Web框架Django实现的。&lt;/p&gt;

&lt;p&gt;通过使用Hue我们可以在浏览器端的Web控制台上与Hadoop集群进行交互来分析处理数据，例如操作HDFS上的数据，运行MapReduce Job，执行Hive的SQL语句，浏览HBase数据库等等。&lt;/p&gt;

&lt;h2 id=&#34;hue链接:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;HUE链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Site: &lt;a href=&#34;http://gethue.com/&#34;&gt;http://gethue.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github: &lt;a href=&#34;https://github.com/cloudera/hue&#34;&gt;https://github.com/cloudera/hue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Reviews: &lt;a href=&#34;https://review.cloudera.org&#34;&gt;https://review.cloudera.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;核心功能:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;核心功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SQL编辑器，支持Hive, Impala, MySQL, Oracle, PostgreSQL, SparkSQL, Solr SQL, Phoenix&amp;hellip;&lt;/li&gt;
&lt;li&gt;搜索引擎Solr的各种图表&lt;/li&gt;
&lt;li&gt;Spark和Hadoop的友好界面支持&lt;/li&gt;
&lt;li&gt;支持调度系统Apache Oozie，可进行workflow的编辑、查看&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HUE提供的这些功能相比Hadoop生态各组件提供的界面更加友好，但是一些需要debug的场景可能还是需要使用原生系统才能更加深入的找到错误的原因。&lt;/p&gt;

&lt;p&gt;HUE中查看Oozie workflow时，也可以很方便的看到整个workflow的DAG图，不过在最新版本中已经将DAG图去掉了，只能看到workflow中的action列表和他们之间的跳转关系，想要看DAG图的仍然可以使用oozie原生的界面系统查看。&lt;/p&gt;

&lt;h3 id=&#34;hue登录:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;HUE登录&lt;/h3&gt;

&lt;p&gt;如果自己搭建了HUE，则可以使用管理员账户创建一个新的用户，然后使用新的用户进行登录，见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%E7%99%BB%E5%BD%95.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE登录图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;a href=&#34;http://gethue.com/&#34;&gt;HUE官网&lt;/a&gt;上的live demo可以尝鲜。如果大家自己没有搭建大数据平台，没有安装HUE的话，可以先在该demo上尝试。点击&lt;a href=&#34;http://demo.gethue.com/&#34;&gt;Play with the live Demo now!&lt;/a&gt;,将会进入HUE的&amp;rdquo;我的文档&amp;rdquo;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%20Demo.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE Demo图&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;hdfs文件浏览:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;HDFS文件浏览&lt;/h3&gt;

&lt;p&gt;HUE可以很方便的浏览HDFS中的目录和文件，并且进行文件和目录的创建、复制、删除、下载以及修改权限等操作。&lt;/p&gt;

&lt;p&gt;HDFS实现了一个和POSIX系统类似的文件和目录的权限模型。每个文件和目录有一个所有者（owner）和一个组（group）。文件或目录对其所有者、同组的其他用户以及所有其他用户分别有着不同的权限。&lt;strong&gt;但，用户身份机制对HDFS本身来说只是外部特性。HDFS并不提供创建用户身份、创建组或处理用户凭证等功能。&lt;/strong&gt; 使用HUE访问HDFS时，HDFS简单的将HUE上的用户名和组的名称进行权限的校验。&lt;/p&gt;

&lt;p&gt;在Live Demo中,点击&amp;rdquo;文件浏览器&amp;rdquo;, 进入HDFS的家目录：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%20File%20Browser.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE HDFS图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS:&lt;/strong&gt; Live Demo中禁了文件上传功能。&lt;/p&gt;

&lt;h3 id=&#34;作业浏览:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;作业浏览&lt;/h3&gt;

&lt;p&gt;点击Job Browser，可以查看作业列表，并且可以通过点击右上角的&amp;rdquo;成功&amp;rdquo;,&amp;ldquo;正在运行&amp;rdquo;,&amp;ldquo;失败&amp;rdquo;,&amp;ldquo;停止&amp;rdquo;来筛选不同状态的作业：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%20Job%20Browser.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE Job Browser&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们在实际工作中发现，当集群(CDH5.2) 配置了HA后，当active的ResourceManager自动切换后(比如NN1上的ResourceManager是active，而NN2是standby，当NN1出现故障， NN2上的ResourceManager转变为active状态)，HUE的job browser将不能够正确显示。只有当修复故障后，将NN1上的ResourceManager重新变成active状态，HUE的job browser才能正常工作。不知道这个问题在后续版本是否已经得到修复。&lt;/p&gt;

&lt;h3 id=&#34;hive查询:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;Hive查询&lt;/h3&gt;

&lt;p&gt;HUE的beeswax app提供友好方便的Hive查询功能，能够选择不同的Hive数据库，编写HQL语句，提交查询任务，并且能够在界面下方看到查询作业运行的日志。在得到结果后，还提供进行简单的图表分析能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%20Hive.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE Hive查询&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点击&amp;rdquo;Data Browsers&amp;rdquo;-&amp;gt;&amp;ldquo;Metastore表&amp;rdquo;，还可以看到Hive中的数据库，数据库中的表以及各个表的元数据等信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%20Hive%20MetaStore.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE Hive MetaStore&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;oozie-workflow编辑:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;Oozie Workflow编辑&lt;/h3&gt;

&lt;p&gt;HUE也提供了很好的Oozie的集成，能够在HUE上创建和编辑Bundles, Coordinator, Workflow. Oozie的介绍可以去&lt;a href=&#34;https://oozie.apache.org/&#34;&gt;官网&lt;/a&gt;查看。下图为在HUE上创建一个新的workflow，在该界面上，可以直接拖动不同的组件，变成DAG中的节点，并且设置各个action的流转逻辑。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%20Workflow%20Editor.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE WF Editor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然Oozie也可以通过命令行的方式提交B,C,W. 不过是使用HUE创建的workflow，或者是通过命令行提交的workflow，都可以在HUE上查看运行的状况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%20Workflow%20Browser.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE WF Browser&#34; /&gt;&lt;/p&gt;

&lt;p&gt;只是通过命令行提交的workflow就不可以在HUE上进行编辑了。使用配置文件、命令行提交的方式能够保证在生产环境上运行的和在测试环境上运行的版本一致，而使用HUE界面编辑的方式虽然方便，但也可能会带来人工操作在生产环境中失误的风险，有利也有弊吧。&lt;/p&gt;

&lt;h2 id=&#34;contribution:4d91db11f2d84cff72c863adcd70ce66&#34;&gt;Contribution&lt;/h2&gt;

&lt;p&gt;我在给同事准备培训材料的时候，到HUE的github上去查找资料。在看到HUE的主要功能时，github上的原文是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/HUE%20Features%20old.png?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5a6L5L2T/fontsize/500/fill/Izk3QjhGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;HUE Features old&#34; /&gt;&lt;/p&gt;

&lt;p&gt;恰好我司主要使用的数据库是PostgreSQL，看到PostGresl感觉怪怪的，于是Google了一把，PostgreSQL有两个名字：PostgreSQL和Postgres，目前&lt;a href=&#34;https://www.postgresql.org/&#34;&gt;官方网站&lt;/a&gt;上的名字仍然是PostgreSQL. 不管PostGresl是否有什么典故，但是PostgreSQL一定是对的。因此，我去查了下如何给HUE提交代码修改。在Github上能找到wiki: &lt;a href=&#34;https://github.com/cloudera/hue/wiki/Contribute-to-HUE&#34;&gt;Contribute to HUE&lt;/a&gt;, HUE有自己的JIRA和Review Board, 但也说了&lt;code&gt;The Hue project gladly welcomes any patches or pull requests!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;于是我在github上给HUE发了一个&lt;a href=&#34;https://github.com/cloudera/hue/issues/371&#34;&gt;Issue&lt;/a&gt;和一个&lt;a href=&#34;https://github.com/cloudera/hue/pull/372&#34;&gt;Pull Request&lt;/a&gt;。几天后Pull Request被接收，merge到了master分支上，可以看到这个&lt;a href=&#34;https://github.com/cloudera/hue/commit/61e80b3cd2820c68f2103e8cef34d50734f02c09&#34;&gt;Commit&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在这里记录一下更新的步骤：
1. Fork HUE的工程，比如 &lt;a href=&#34;https://github.com/ywheel/hue&#34;&gt;ywheel/hue&lt;/a&gt;
2. 创建一个新的分支，不要使用master分支提交修改。比如我创建了&lt;a href=&#34;https://github.com/ywheel/hue/tree/fix-postgresql-spelling&#34;&gt;fix-postgresql-spelling&lt;/a&gt;分支。
3. 将代码pull下来，修改后commit，提交到&lt;a href=&#34;https://github.com/ywheel/hue/tree/fix-postgresql-spelling&#34;&gt;fix-postgresql-spelling&lt;/a&gt;分支。
4. 创建issue。当HUE的工程上创建&lt;a href=&#34;https://github.com/cloudera/hue/issues/371&#34;&gt;issue&lt;/a&gt;, 描述清楚问题，提交。
5. 点击&amp;rsquo;Pull Request&amp;rsquo;, 选择目的工程和分支，比如cloudera/hue的master分支。填写comment, 说明已创建的issue, create pull request.&lt;/p&gt;

&lt;p&gt;接下来就是等了，等该提交被review, 被merge到master分支, 等你自己的名字出现在&lt;a href=&#34;https://github.com/cloudera/hue/graphs/contributors&#34;&gt;Contributors&lt;/a&gt;里面, &lt;strong&gt;then everything DONE!&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ps: 虽然改了个单词拼写就出来说简直是丢人，不过算是一个good start, 希望能在不久的将来真的能给开源项目（特别是流行的大数据生态中的开源项目）贡献代码，加油!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>老家</title>
      <link>http://blog.ywheel.cn/post/2016/05/18/family/</link>
      <pubDate>Wed, 18 May 2016 02:41:01 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2016/05/18/family/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://o75oehjrs.bkt.clouddn.com/image/blog/%E8%80%81%E5%AE%B6.jpg?watermark/2/text/YmxvZy55d2hlZWwuY24=/font/5b6u6L2v6ZuF6buR/fontsize/500/fill/I0Y1RUZFRg==/dissolve/100/gravity/SouthEast/dx/10/dy/10&#34; alt=&#34;老家门前的三棵枣树&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图：老家门前的三棵枣树&lt;/p&gt;

&lt;p&gt;5年前的今天，老家拆除了，在老家的原址上，早已盖起一栋新楼。这边文章就是在老家拆除后的几天写的，用来纪念我们心中的&amp;rdquo;老家&amp;rdquo;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;老家在经历了几十年的风雨后，终于到了该退休的年龄。爸爸在每当下大雨时就担心老家会不会扛不住，这种担心也在前两天彻底结束。昨天给家里通电话，得知老家已经拆的只剩下半身高的红砖墙，紧接着红砖墙也会被拆掉，在老家的那片土地上会重新盖起一栋新楼。&lt;/p&gt;

&lt;p&gt;老家，也只能是记忆中的老家了。&lt;/p&gt;

&lt;p&gt;童年有很多时间在老家度过。甚至上了小学后，只要放假不上课，还经常闹着要回老家。在那里可以玩一些很有意思的事情。还记得门口的那块大石头，常年经受水滴的拍击，在石头的表面凹进去很大一块，也许这就是“水滴石穿”的典例吧。八仙桌的竹椅子，被装上滚轮的改装摇篮，门口地里的蚯蚓，菜园里的土青蛙，屋檐下的打谷机，还有门口的三棵枣树，守护红枣的水枪。。。小时候的玩意儿还是很丰富多彩。&lt;/p&gt;

&lt;p&gt;尤其是那三棵枣树，每当暑假，红枣挂满枝头，爷爷奶奶都要召集家中所有的小孩回到老家打红枣。长辈们用长竹竿敲打树枝，红枣自然会掉下来，然后我们小孩就负责从地上把红枣捡回来，就算经常被“天上”掉下来的红枣砸到头，也不亦乐乎地忙活着捡红枣。邻居家的小孩就站在旁边看着，吞着口水。偶尔有一两颗红枣敲好掉到他们跟前，他们就立马捡起来就跑。上小学的时候，枣树上结的红枣还是挺多的，一般都能打下两箩筐满满的红枣，也会分给隔壁邻居一些。&lt;/p&gt;

&lt;p&gt;“古有‘先生不知何许人也，亦不详其姓字，宅边有五柳树，因以为号焉’，我家门口有三棵枣树，好读书，更要好好读书。。。”这是爷爷指导我们写的作文。爷爷是革命年代的读书人，学的国文，善于吟诗作赋，对对子，写的一手好毛笔字，另外还是一位“江湖郎中”，有一套治疗胃病的特效药方。我小时候，经常会有人不远千里从隔壁隔壁县一直打听，直到打听到老家里，那时电话远没有普及，所以病人只能到处托人打听，药方确实特效，所以爷爷也声名远扬。也经常会有村里的不识字的老人，拿着儿女寄来的信件找爷爷读，然后回信。爷爷对我们很好，毛笔字也是经过他的启蒙，他很享受教育孙辈的感觉，他还指导我们写过一首诗，叫《电灯》：有电真方便，开灯亮堂堂。公孙在一起，读书写文章。
小学四年级后，我们开始自己骑车。于是每次回老家，我家四口人就骑着四辆自行车浩浩荡荡得骑上大半小时。每次在老家聚集，门口都停满了自行车。从四姑父买了全家第一辆摩托车，才开始逐渐改变交通工具被腿和自行车垄断的状况。&lt;/p&gt;

&lt;p&gt;上初中后，慢慢习惯在县城住的生活，卫生条件也好一些。老家没有卫生间，电视没有有线，只有很少的几个台。我们也都开始青春期的叛逆，慢慢不愿回去那个看不了电视，上厕所环境不好，洗澡也没卫生间的老家。除了每年暑假例行的打红枣的时候，都回去帮忙，然后各小家分一包回去。枣树却越来越不给力，红枣数量逐年递减，还有隔壁的小孩也长大，学会爬树和偷枣，所以我们得回去看守枣树。直到初三那年，突然某天半夜还在打点滴却睡着的我被叫醒，点滴还没完就强行拔针，一家人匆忙得坐着救护车赶回老家，还是没能见上爷爷最后一面。爷爷早以写好自己的挽联，教过我们好几次，但是我们却都没太放在心上。到最后爷爷过世，没人能完整的记起挽联的内容，一直后悔不已。&lt;/p&gt;

&lt;p&gt;爷爷一直教育我们要好好读书。当年他考上师范的时候，全村人一起拱他读书。在这方面，他一直是全家人的榜样。他过世后，我们两兄弟也很争气，拿了我们初中的第二和第三名考上了高中。&lt;/p&gt;

&lt;p&gt;上了高中后，爸爸也买了摩托车，去老家就更方便了。摩托车比自行车快多了，而且在回老家的路上有一个又长又抖的坡，不再那么费力以至于得自己下车推着上坡了。村口也慢慢修了路，没有了那条弯曲而又满是泥泞的土路。基本上那会开始，在老家门口停的车，摩托比自行车要多了。大家庭的人口也在增长，表哥表姐陆续开始结婚，为家族添丁。还好老家门口的院子空间大，够摆放那么多车。&lt;/p&gt;

&lt;p&gt;上大学后，回老家的机会就更少了，基本不会在老家住了。交通也方便，再晚也能回到县城住。记得有一年暑假回去，弟弟说哥哥你们可回来了，就等你们来打红枣，树顶上那些都快被鸟儿吃完了。于是又干起小时候的活，忙活一阵把那三棵枣树上的红枣都打下来，但总共却只有很少很少了。洗好后大家分一分吃几颗，都快吃完了。枣树也年纪大了，红枣的产量早已不及当年的两大箩筐。&lt;/p&gt;

&lt;p&gt;老家也年纪大了，最近几年，只要一下大雨，爸爸就担心老家会不会倒。好像是大一那年，老家后的一间年代更久一点的房子在一个雷雨交加的夜晚倒塌了。在我的记忆中，小时候还在那间房子里玩过捉迷藏，我躲在里面的稻草堆里。因为是同样的土砖房，老家也难免会有同样的命运。不过由于老家曾经修缮过，把最底层的承重的土砖换成了红砖，使用年限又增加了几年。&lt;/p&gt;

&lt;p&gt;大家的交通工具又有了新变化，慢慢的，老家前的院子里不再只停着两个轮子的车子了。一两辆小车就要把院子停满。叔叔说以后要盖一间带大车库的新“老家”，老家的拆除也提上日程。该来的总要来的。。。&lt;/p&gt;

&lt;p&gt;现在的老家，只剩一些砖头了。为了不让老家在某个雨天轰然倒下，伤及还在老家住着的叔叔一家还有奶奶，也怕损坏老家的一些家具财务，所以还是选择了自己拆除。就在5月18号，开始拆除老家。在老家的原址上，将来会重新盖一栋新楼。也许会有一个大车库，就算以后兄弟们每人开辆车回去也能放下；也许会有一个精装修的卫生间，卫生条件也跟上城里的脚步；也许会有一个很大的院子，院子里还有三棵年老的枣树。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grep命令的与或非</title>
      <link>http://blog.ywheel.cn/post/2015/03/17/grep_and_or_not/</link>
      <pubDate>Tue, 17 Mar 2015 00:37:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/17/grep_and_or_not/</guid>
      <description>

&lt;pre&gt;&lt;code&gt;原文标题：
7 Linux Grep OR, Grep AND, Grep NOT Operator Examples
原文地址：
http://www.thegeekstuff.com/2011/10/grep-or-and-not-operators/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Question: Can you explain how to use OR, AND and NOT operators in Unix grep command with some examples?&lt;/p&gt;

&lt;p&gt;Answer: In grep, we have options equivalent to OR and NOT operators. There is no grep AND opearator. But, you can simulate AND using patterns. The examples mentioned below will help you to understand how to use OR, AND and NOT in Linux grep command.&lt;/p&gt;

&lt;p&gt;The following employee.txt file is used in the following examples.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat employee.txt
100  Thomas  Manager    Sales       $5,000
200  Jason   Developer  Technology  $5,500
300  Raj     Sysadmin   Technology  $7,000
400  Nisha   Manager    Marketing   $9,500
500  Randy   Manager    Sales       $6,000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You already knew that grep is extremely powerful based on these &lt;a href=&#34;http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/&#34;&gt;grep command examples&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;grep-or-operator:af29bf61cfd36b81a59758fe3b1cf731&#34;&gt;Grep OR Operator&lt;/h3&gt;

&lt;p&gt;Use any one of the following 4 methods for grep OR. I prefer method number 3 mentioned below for grep OR operator.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Grep OR Using |&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you use the grep command without any option, you need to use | to separate multiple patterns for the or condition.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep &#39;pattern1\|pattern2&#39; filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, grep either Tech or Sales from the employee.txt file. Without the back slash in front of the pipe, the following will not work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep &#39;Tech\|Sales&#39; employee.txt
100  Thomas  Manager    Sales       $5,000
200  Jason   Developer  Technology  $5,500
300  Raj     Sysadmin   Technology  $7,000
500  Randy   Manager    Sales       $6,000
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Grep OR Using -E&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;grep -E option is for extended regexp. If you use the grep command with -E option, you just need to use | to separate multiple patterns for the or condition.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -E &#39;pattern1|pattern2&#39; filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, grep either Tech or Sales from the employee.txt file. Just use the | to separate multiple OR patterns.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep -E &#39;Tech|Sales&#39; employee.txt
100  Thomas  Manager    Sales       $5,000
200  Jason   Developer  Technology  $5,500
300  Raj     Sysadmin   Technology  $7,000
500  Randy   Manager    Sales       $6,000
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Grep OR Using egrep&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;egrep is exactly same as ‘grep -E’. So, use egrep (without any option) and separate multiple patterns for the or condition.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;egrep &#39;pattern1|pattern2&#39; filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, grep either Tech or Sales from the employee.txt file. Just use the | to separate multiple OR patterns.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ egrep &#39;Tech|Sales&#39; employee.txt
100  Thomas  Manager    Sales       $5,000
200  Jason   Developer  Technology  $5,500
300  Raj     Sysadmin   Technology  $7,000
500  Randy   Manager    Sales       $6,000
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Grep OR Using grep -e&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using grep -e option you can pass only one parameter. Use multiple -e option in a single command to use multiple patterns for the or condition.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -e pattern1 -e pattern2 filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, grep either Tech or Sales from the employee.txt file. Use multiple -e option with grep for the multiple OR patterns.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep -e Tech -e Sales employee.txt
100  Thomas  Manager    Sales       $5,000
200  Jason   Developer  Technology  $5,500
300  Raj     Sysadmin   Technology  $7,000
500  Randy   Manager    Sales       $6,000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grep-and:af29bf61cfd36b81a59758fe3b1cf731&#34;&gt;Grep AND&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Grep AND using -E ‘pattern1.*pattern2′&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There is no AND operator in grep. But, you can simulate AND using grep -E option.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -E &#39;pattern1.*pattern2&#39; filename
grep -E &#39;pattern1.*pattern2|pattern2.*pattern1&#39; filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following example will grep all the lines that contain both “Dev” and “Tech” in it (in the same order).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep -E &#39;Dev.*Tech&#39; employee.txt
200  Jason   Developer  Technology  $5,500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following example will grep all the lines that contain both “Manager” and “Sales” in it (in any order).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep -E &#39;Manager.*Sales|Sales.*Manager&#39; employee.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: Using &lt;a href=&#34;http://www.thegeekstuff.com/2011/01/advanced-regular-expressions-in-grep-command-with-10-examples-%E2%80%93-part-ii/&#34;&gt;regular expressions in grep&lt;/a&gt; is very powerful if you know how to use it effectively.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Grep AND using Multiple grep command&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can also use multiple grep command separated by pipe to simulate AND scenario.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -E &#39;pattern1&#39; filename | grep -E &#39;pattern2&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following example will grep all the lines that contain both “Manager” and “Sales” in the same line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep Manager employee.txt | grep Sales
100  Thomas  Manager    Sales       $5,000
500  Randy   Manager    Sales       $6,000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grep-not:af29bf61cfd36b81a59758fe3b1cf731&#34;&gt;Grep NOT&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Grep NOT using grep -v&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Using grep -v you can simulate the NOT conditions. -v option is for invert match. i.e It matches all the lines except the given pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep -v &#39;pattern1&#39; filename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, display all the lines except those that contains the keyword “Sales”.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ grep -v Sales employee.txt
200  Jason   Developer  Technology  $5,500
300  Raj     Sysadmin   Technology  $7,000
400  Nisha   Manager    Marketing   $9,500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also combine NOT with other operator to get some powerful combinations.&lt;/p&gt;

&lt;p&gt;For example, the following will display either Manager or Developer (bot ignore Sales).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ egrep &#39;Manager|Developer&#39; employee.txt | grep -v Sales
200  Jason   Developer  Technology  $5,500
400  Nisha   Manager    Marketing   $9,500
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;总结:af29bf61cfd36b81a59758fe3b1cf731&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;总结起来就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OR: \|, -E， -e, egrep
AND: -E, grep | grep
NOT: -v
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 119 Pascal&#39;s Triangle II</title>
      <link>http://blog.ywheel.cn/post/2015/03/17/leetcode_119/</link>
      <pubDate>Tue, 17 Mar 2015 00:16:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/17/leetcode_119/</guid>
      <description>&lt;p&gt;题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://leetcode.com/problems/pascals-triangle-ii/
Given an index k, return the kth row of the Pascal&#39;s triangle.

For example, given k = 3,
Return [1,3,3,1].

Note:
Could you optimize your algorithm to use only O(k) extra space?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解法较容易，时间复杂度依然是0(n^2)，要实现空间复杂度得考虑在内层循环时从后往前看，这样的话上一行的结果不会被覆盖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {  
    public List&amp;lt;Integer&amp;gt; getRow(int rowIndex) {  
        if (rowIndex &amp;lt; 0) return null;  
        List&amp;lt;Integer&amp;gt; results = new ArrayList&amp;lt;Integer&amp;gt;(rowIndex + 1);  
        for (int row=0; row &amp;lt; rowIndex; row++) {  
            results.add(1);  
            for (int i=row; i&amp;gt;0; i--) {  
                results.set(i, results.get(i - 1) + results.get(i));  
            }  
        }  
        results.add(1); // add last 1  
        return results;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 023 Merge K Sorted Lists</title>
      <link>http://blog.ywheel.cn/post/2015/03/12/leetcode_23/</link>
      <pubDate>Thu, 12 Mar 2015 02:52:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/12/leetcode_23/</guid>
      <description>

&lt;p&gt;题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://leetcode.com/problems/merge-k-sorted-lists/
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;解法一:2f76cdb9ba8135cac819db3ef84952c8&#34;&gt;解法一&lt;/h3&gt;

&lt;p&gt;将K个链表做K-1次归并，每次归并是对两个链表的归并，最终得到一个排序的链表。即：
1，2合并，遍历2n个节点；(1,2)与3合并，遍历3n个节点。。。(1&amp;hellip;k-1)与k合并，遍历kn个节点。所以总共遍历n&lt;em&gt;(2+3+&amp;hellip;+k)=n&lt;/em&gt;(k^2+k-2)/2，那么时间复杂度为O(n*k^2)。&lt;/p&gt;

&lt;h3 id=&#34;解法二:2f76cdb9ba8135cac819db3ef84952c8&#34;&gt;解法二&lt;/h3&gt;

&lt;p&gt;对解法一改进一下，改用分治法，所以时间复杂度变为O(nklogk)。&lt;/p&gt;

&lt;h3 id=&#34;解法三:2f76cdb9ba8135cac819db3ef84952c8&#34;&gt;解法三&lt;/h3&gt;

&lt;p&gt;将K个链表的首元素都取出来，选择出最小的那个作为新链表的head。然后将该元素的next取出来，与其他链表的元素比较再选一个小的，放到新链表中。选择出最小元素的时间复杂度为O(k), 总共要选nk次，所以时间复杂度为O(n*k^2)。&lt;/p&gt;

&lt;h3 id=&#34;解法四:2f76cdb9ba8135cac819db3ef84952c8&#34;&gt;解法四&lt;/h3&gt;

&lt;p&gt;对解法三改进一下，用最小堆来实现选择最小元素的要求，则时间复杂度降为O(logk)，则总的时间复杂度为O(nklogk)，与解法二的时间复杂度一样。在Java中，可以使用基于
最小堆算法的PriorityQueue来作为最小堆的集合类。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 
 * Definition for singly-linked list. 
 * public class ListNode { 
 *     int val; 
 *     ListNode next; 
 *     ListNode(int x) { 
 *         val = x; 
 *         next = null; 
 *     } 
 * } 
 */  
public class Solution {  
    public ListNode mergeKLists(List&amp;lt;ListNode&amp;gt; lists) {  
        if (lists == null || lists.isEmpty()) {  
            return null;  
        }  
        PriorityQueue&amp;lt;ListNode&amp;gt; minHeap = new PriorityQueue&amp;lt;ListNode&amp;gt;(new Comparator&amp;lt;ListNode&amp;gt;(){  
            public int compare(ListNode l1, ListNode l2) {  
                return Integer.compare(l1.val, l2.val);  
            }  
        });  
        for (ListNode node : lists) {  
            if (node != null) {  
                minHeap.add(node);  
            }  
        }  
        ListNode helper = new ListNode(0);  
        ListNode next = helper;  
        while (!minHeap.isEmpty()) {  
            ListNode min = minHeap.poll(); // must not be null  
            next.next = min;  
            min = min.next;  
            if (min != null) {  
                minHeap.add(min);  
            }  
            next = next.next;  
        }  
        return helper.next;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 021 Merge Two Sorted Lists</title>
      <link>http://blog.ywheel.cn/post/2015/03/12/leetcode_21/</link>
      <pubDate>Thu, 12 Mar 2015 01:43:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/12/leetcode_21/</guid>
      <description>&lt;p&gt;题：&lt;/p&gt;

&lt;p&gt;````
&lt;a href=&#34;https://leetcode.com/problems/merge-two-sorted-lists/&#34;&gt;https://leetcode.com/problems/merge-two-sorted-lists/&lt;/a&gt;
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
解法一：创建一个新的链表：

```java
/** 
 * Definition for singly-linked list. 
 * public class ListNode { 
 *     int val; 
 *     ListNode next; 
 *     ListNode(int x) { 
 *         val = x; 
 *         next = null; 
 *     } 
 * } 
 */  
public class Solution {  
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {  
        if (l1 == null &amp;amp;&amp;amp; l2 == null) {  
            return null;  
        } else if (l1 == null) {  
            return l2;  
        } else if (l2 == null) {  
            return l1;  
        } else {  
            ListNode head = null;  
            ListNode next = new ListNode(0); // before head  
            while (l1 != null || l2 != null) {  
                if (l1 != null &amp;amp;&amp;amp; l2 != null) {  
                    if (l1.val &amp;lt; l2.val) {  
                        next.next = l1;  
                        l1 = l1.next;  
                    } else {  
                        next.next = l2;  
                        l2 = l2.next;  
                    }  
                } else if (l1 == null) {  
                    next.next = l2;  
                    l2 = l2.next;  
                } else {  
                    next.next = l1;  
                    l1 = l1.next;  
                }  
                head = head == null ? next.next : head;  
                next = next.next;  
            }  
            return head;  
        }  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解法二：将l2加入到l1中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 
 * Definition for singly-linked list. 
 * public class ListNode { 
 *     int val; 
 *     ListNode next; 
 *     ListNode(int x) { 
 *         val = x; 
 *         next = null; 
 *     } 
 * } 
 */  
public class Solution {  
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {  
        if (l1 == null &amp;amp;&amp;amp; l2 == null) {  
            return null;  
        } else if (l1 == null) {  
            return l2;  
        } else if (l2 == null) {  
            return l1;  
        } else {  
            // merge l2 to l1  
            ListNode head = null;  
            ListNode prev = null;  
            while (l2 != null) {  
                if (l1 == null) {  
                    prev.next = l2;  
                    break;  
                }  
                if (l1.val &amp;gt; l2.val) {  
                    if (prev == null) {  
                        prev = l2;  
                    } else {  
                        prev.next = l2;  
                    }  
                    ListNode node = l2.next;  
                    l2.next = l1;  
                    prev = l2;  
                    l2 = node;  
                } else {  
                    prev = l1;  
                    l1 = l1.next;  
                }  
                head = head == null ? prev : head;  
                  
            }  
            return head;  
        }  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 088 Merge Sorted Array</title>
      <link>http://blog.ywheel.cn/post/2015/03/12/leetcode_88/</link>
      <pubDate>Thu, 12 Mar 2015 00:36:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/12/leetcode_88/</guid>
      <description>&lt;p&gt;题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://leetcode.com/problems/merge-sorted-array/
Given two sorted integer arrays A and B, merge B into A as one sorted array.

Note:
You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {  
    public void merge(int A[], int m, int B[], int n) {  
        if (A == null || B == null || A.length == 0 || B.length == 0 || A.length &amp;lt;  m+n) {  
            return;  
        }  
        int a = m - 1;  
        int b = n - 1;  
        for (int i=m+n-1; i&amp;gt;=0; i--) {  
            if (a &amp;gt;=0 &amp;amp;&amp;amp; b &amp;gt;= 0) {  
                if (A[a] &amp;gt; B[b]) {  
                    A[i] = A[a--];  
                } else {  
                    A[i] = B[b--];  
                }  
            } else if (a &amp;lt; 0) {  
                // only left B  
                System.arraycopy(B, 0, A, 0, i+1);  
            } // else {  
                // only left A, do nothing  
            //}  
        }  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;往事不堪回首，当初某游戏公司的面试尽然倒在这题上，哎。。。说多了都是泪&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 147 Insertion Sort List</title>
      <link>http://blog.ywheel.cn/post/2015/03/12/leetcode_147/</link>
      <pubDate>Thu, 12 Mar 2015 00:16:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/12/leetcode_147/</guid>
      <description>&lt;p&gt;题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://leetcode.com/problems/insertion-sort-list/
Sort a linked list using insertion sort.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 
 * Definition for singly-linked list. 
 * public class ListNode { 
 *     int val; 
 *     ListNode next; 
 *     ListNode(int x) { 
 *         val = x; 
 *         next = null; 
 *     } 
 * } 
 */  
public class Solution {  
    public ListNode insertionSortList(ListNode head) {  
        if (head == null) return head;  
        // start from second node  
        ListNode node = head.next;  
        ListNode nodePrev = head;  
        while (node != null) {  
            // start from head node  
            ListNode prev = head;  
            ListNode curr = head;  
            while (curr != node) {  
                if (node.val &amp;lt; curr.val) {  
                    // insert node before curr  
                    nodePrev.next = node.next;  
                    node.next = curr;  
                    if (curr == head) {  
                        head = node;  
                    } else {  
                        prev.next = node;  
                    }  
                    node = nodePrev.next;  
                    break;  
                } else {  
                    // continue  
                    prev = curr == head ? head : prev.next;  
                    curr = curr.next;  
                }  
            }  
            if (curr == node) {  
                node = node.next;  
                nodePrev = nodePrev.next;  
            }  
        }  
        return head;  
    }  
}  

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 题目总结/分类</title>
      <link>http://blog.ywheel.cn/post/2015/03/11/leetcode_summary/</link>
      <pubDate>Wed, 11 Mar 2015 01:36:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/11/leetcode_summary/</guid>
      <description>

&lt;pre&gt;&lt;code&gt;转载自豆瓣： http://www.douban.com/note/330562764/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;的确需要有一个分类列表在指导自己在准备时间不够充分的情况下接触到更多考点的题&lt;/p&gt;

&lt;h3 id=&#34;利用堆栈:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;利用堆栈：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/&#34;&gt;http://oj.leetcode.com/problems/evaluate-reverse-polish-notation/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/longest-valid-parentheses/（也可以用一维数组，贪心）&#34;&gt;http://oj.leetcode.com/problems/longest-valid-parentheses/（也可以用一维数组，贪心）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/valid-parentheses/&#34;&gt;http://oj.leetcode.com/problems/valid-parentheses/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/largest-rectangle-in-histogram/&#34;&gt;http://oj.leetcode.com/problems/largest-rectangle-in-histogram/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;特别注意细节：&lt;a href=&#34;http://oj.leetcode.com/problems/trapping-rain-water/&#34;&gt;http://oj.leetcode.com/problems/trapping-rain-water/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;多种数据结构:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;多种数据结构：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/lru-cache/&#34;&gt;http://oj.leetcode.com/problems/lru-cache/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/&#34;&gt;http://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/&lt;/a&gt;
(注意遍历方法）&lt;/li&gt;
&lt;li&gt;HASH：&lt;a href=&#34;http://oj.leetcode.com/problems/longest-consecutive-sequence/&#34;&gt;http://oj.leetcode.com/problems/longest-consecutive-sequence/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;简单编程:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;简单编程：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/longest-common-prefix/&#34;&gt;http://oj.leetcode.com/problems/longest-common-prefix/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/string-to-integer-atoi/&#34;&gt;http://oj.leetcode.com/problems/string-to-integer-atoi/&lt;/a&gt;
(分析，控制语句）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;排序-查找:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;排序 &amp;amp; 查找：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;二分查找：&lt;a href=&#34;http://oj.leetcode.com/problems/search-a-2d-matrix/&#34;&gt;http://oj.leetcode.com/problems/search-a-2d-matrix/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;二分查找进阶：&lt;a href=&#34;http://oj.leetcode.com/problems/search-for-a-range/&#34;&gt;http://oj.leetcode.com/problems/search-for-a-range/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;二分查找应用：&lt;a href=&#34;http://oj.leetcode.com/problems/sqrtx/&#34;&gt;http://oj.leetcode.com/problems/sqrtx/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;二分查找应用：&lt;a href=&#34;http://oj.leetcode.com/problems/search-insert-position/&#34;&gt;http://oj.leetcode.com/problems/search-insert-position/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;二分查找变种：&lt;a href=&#34;http://oj.leetcode.com/problems/search-in-rotated-sorted-array/&#34;&gt;http://oj.leetcode.com/problems/search-in-rotated-sorted-array/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;二分查找变种：&lt;a href=&#34;http://oj.leetcode.com/problems/search-in-rotated-sorted-array--&#34;&gt;http://oj.leetcode.com/problems/search-in-rotated-sorted-array--&lt;/a&gt; ii/&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;简单数学:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;简单数学：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/pascals-triangle/&#34;&gt;http://oj.leetcode.com/problems/pascals-triangle/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/pascals-triangle-ii/&#34;&gt;http://oj.leetcode.com/problems/pascals-triangle-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/powx-n/&#34;&gt;http://oj.leetcode.com/problems/powx-n/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/reverse-integer/&#34;&gt;http://oj.leetcode.com/problems/reverse-integer/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/plus-one/&#34;&gt;http://oj.leetcode.com/problems/plus-one/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/unique-paths/&#34;&gt;http://oj.leetcode.com/problems/unique-paths/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/palindrome-number/&#34;&gt;http://oj.leetcode.com/problems/palindrome-number/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/permutation-sequence/&#34;&gt;http://oj.leetcode.com/problems/permutation-sequence/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/merge-intervals/&#34;&gt;http://oj.leetcode.com/problems/merge-intervals/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/valid-number/&#34;&gt;http://oj.leetcode.com/problems/valid-number/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/climbing-stairs/&#34;&gt;http://oj.leetcode.com/problems/climbing-stairs/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/roman-to-integer/&#34;&gt;http://oj.leetcode.com/problems/roman-to-integer/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/integer-to-roman/&#34;&gt;http://oj.leetcode.com/problems/integer-to-roman/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/divide-two-integers/&#34;&gt;http://oj.leetcode.com/problems/divide-two-integers/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;区间：&lt;a href=&#34;http://oj.leetcode.com/problems/insert-interval/&#34;&gt;http://oj.leetcode.com/problems/insert-interval/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大数的数学运算:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;大数的数学运算：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/add-binary/&#34;&gt;http://oj.leetcode.com/problems/add-binary/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/add-two-numbers/&#34;&gt;http://oj.leetcode.com/problems/add-two-numbers/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;数组:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;数组：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/remove-element/&#34;&gt;http://oj.leetcode.com/problems/remove-element/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/merge-sorted-array/&#34;&gt;http://oj.leetcode.com/problems/merge-sorted-array/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/first-missing-positive/&#34;&gt;http://oj.leetcode.com/problems/first-missing-positive/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/spiral-matrix/&#34;&gt;http://oj.leetcode.com/problems/spiral-matrix/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/spiral-matrix-ii/&#34;&gt;http://oj.leetcode.com/problems/spiral-matrix-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/rotate-image/&#34;&gt;http://oj.leetcode.com/problems/rotate-image/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历技巧：&lt;a href=&#34;http://oj.leetcode.com/problems/Container-with-most-water/&#34;&gt;http://oj.leetcode.com/problems/Container-with-most-water/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/two-sum/&#34;&gt;http://oj.leetcode.com/problems/two-sum/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/3sum/&#34;&gt;http://oj.leetcode.com/problems/3sum/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/3sum-closest/&#34;&gt;http://oj.leetcode.com/problems/3sum-closest/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/4sum/&#34;&gt;http://oj.leetcode.com/problems/4sum/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/set-matrix-zeroes/&#34;&gt;http://oj.leetcode.com/problems/set-matrix-zeroes/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;用好标记数组：&lt;a href=&#34;http://oj.leetcode.com/problems/valid-sudoku/&#34;&gt;http://oj.leetcode.com/problems/valid-sudoku/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/next-permutation/&#34;&gt;http://oj.leetcode.com/problems/next-permutation/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/word-search/&#34;&gt;http://oj.leetcode.com/problems/word-search/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/&#34;&gt;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/&#34;&gt;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-array-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/sort-colors/&#34;&gt;http://oj.leetcode.com/problems/sort-colors/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;暴力方法-细节实现:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;暴力方法/细节实现：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/max-points-on-a-line/&#34;&gt;http://oj.leetcode.com/problems/max-points-on-a-line/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;链表:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;链表：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;归并排序：&lt;a href=&#34;http://oj.leetcode.com/problems/sort-list/&#34;&gt;http://oj.leetcode.com/problems/sort-list/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;插入排序：&lt;a href=&#34;http://oj.leetcode.com/problems/insertion-sort-list/&#34;&gt;http://oj.leetcode.com/problems/insertion-sort-list/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;反转、插入：&lt;a href=&#34;http://oj.leetcode.com/problems/reorder-list/&#34;&gt;http://oj.leetcode.com/problems/reorder-list/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;检测是否有环：&lt;a href=&#34;http://oj.leetcode.com/problems/linked-list-cycle/&#34;&gt;http://oj.leetcode.com/problems/linked-list-cycle/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;确定链表环的起点：&lt;a href=&#34;http://oj.leetcode.com/problems/linked-list-cycle-ii/&#34;&gt;http://oj.leetcode.com/problems/linked-list-cycle-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Deep Copy 带有随机指针的链表：&lt;a href=&#34;http://oj.leetcode.com/problems/copy-list-with--&#34;&gt;http://oj.leetcode.com/problems/copy-list-with--&lt;/a&gt; random-pointer/&lt;/li&gt;
&lt;li&gt;链表细节：&lt;a href=&#34;http://oj.leetcode.com/problems/rotate-list/&#34;&gt;http://oj.leetcode.com/problems/rotate-list/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/&#34;&gt;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;删除细节：&lt;a href=&#34;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list--&#34;&gt;http://oj.leetcode.com/problems/remove-duplicates-from-sorted-list--&lt;/a&gt; ii/&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/partition-list/&#34;&gt;http://oj.leetcode.com/problems/partition-list/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/swap-nodes-in-pairs/&#34;&gt;http://oj.leetcode.com/problems/swap-nodes-in-pairs/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Merge 两个链表：&lt;a href=&#34;http://oj.leetcode.com/problems/merge-two-sorted-lists/&#34;&gt;http://oj.leetcode.com/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Merge 多链表：&lt;a href=&#34;http://oj.leetcode.com/problems/merge-k-sorted-lists/&#34;&gt;http://oj.leetcode.com/problems/merge-k-sorted-lists/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;细节：&lt;a href=&#34;http://oj.leetcode.com/problems/reverse-nodes-in-k-group/&#34;&gt;http://oj.leetcode.com/problems/reverse-nodes-in-k-group/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/&#34;&gt;http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/reverse-linked-list-ii/&#34;&gt;http://oj.leetcode.com/problems/reverse-linked-list-ii/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;二叉树遍历-递归-非递归:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;二叉树遍历：递归 &amp;amp; 非递归&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/same-tree/&#34;&gt;http://oj.leetcode.com/problems/same-tree/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;前序：&lt;a href=&#34;http://oj.leetcode.com/problems/binary-tree-preorder-traversal/&#34;&gt;http://oj.leetcode.com/problems/binary-tree-preorder-traversal/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中序：&lt;a href=&#34;http://oj.leetcode.com/problems/binary-tree-inorder-traversal/&#34;&gt;http://oj.leetcode.com/problems/binary-tree-inorder-traversal/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;后序：&lt;a href=&#34;http://oj.leetcode.com/problems/binary-tree-postorder-traversal/&#34;&gt;http://oj.leetcode.com/problems/binary-tree-postorder-traversal/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/sum-root-to-leaf-numbers/&#34;&gt;http://oj.leetcode.com/problems/sum-root-to-leaf-numbers/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/path-sum/&#34;&gt;http://oj.leetcode.com/problems/path-sum/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/path-sum-ii/&#34;&gt;http://oj.leetcode.com/problems/path-sum-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/maximum-depth-of-binary-tree/&#34;&gt;http://oj.leetcode.com/problems/maximum-depth-of-binary-tree/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/minimum-depth-of-binary-tree/&#34;&gt;http://oj.leetcode.com/problems/minimum-depth-of-binary-tree/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;重建二叉树：&lt;a href=&#34;http://oj.leetcode.com/problems/construct-binary-tree-from-preorder-&#34;&gt;http://oj.leetcode.com/problems/construct-binary-tree-from-preorder-&lt;/a&gt; -and-inorder-traversal/&lt;/li&gt;
&lt;li&gt;重建二叉树：&lt;a href=&#34;http://oj.leetcode.com/problems/construct-binary-tree-from-inorder--&#34;&gt;http://oj.leetcode.com/problems/construct-binary-tree-from-inorder--&lt;/a&gt; and-postorder-traversal/&lt;/li&gt;
&lt;li&gt;层次遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/binary-tree-zigzag-level-order--&#34;&gt;http://oj.leetcode.com/problems/binary-tree-zigzag-level-order--&lt;/a&gt; traversal/&lt;/li&gt;
&lt;li&gt;遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/symmetric-tree/&#34;&gt;http://oj.leetcode.com/problems/symmetric-tree/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历应用：&lt;a href=&#34;http://oj.leetcode.com/problems/binary-tree-maximum-path-sum/&#34;&gt;http://oj.leetcode.com/problems/binary-tree-maximum-path-sum/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历应用：&lt;a href=&#34;http://oj.leetcode.com/problems/balanced-binary-tree/&#34;&gt;http://oj.leetcode.com/problems/balanced-binary-tree/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历应用：&lt;a href=&#34;http://oj.leetcode.com/problems/recover-binary-search-tree/&#34;&gt;http://oj.leetcode.com/problems/recover-binary-search-tree/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;遍历应用：&lt;a href=&#34;http://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/&#34;&gt;http://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;level遍历：&lt;a href=&#34;http://oj.leetcode.com/problems/binary-tree-level-order-traversal/&#34;&gt;http://oj.leetcode.com/problems/binary-tree-level-order-traversal/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;level 遍历：&lt;a href=&#34;http://oj.leetcode.com/problems/binary-tree-level-order-traversal--&#34;&gt;http://oj.leetcode.com/problems/binary-tree-level-order-traversal--&lt;/a&gt; ii/&lt;/li&gt;
&lt;li&gt;level 遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/populating-next-right-pointers--&#34;&gt;http://oj.leetcode.com/problems/populating-next-right-pointers--&lt;/a&gt; in-each-node/&lt;/li&gt;
&lt;li&gt;level 遍历变种：&lt;a href=&#34;http://oj.leetcode.com/problems/populating-next-right-pointers--&#34;&gt;http://oj.leetcode.com/problems/populating-next-right-pointers--&lt;/a&gt; in-each-node-ii/&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;问题分析-智商-细节:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;问题分析/智商/细节：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/single-number/&#34;&gt;http://oj.leetcode.com/problems/single-number/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/single-number-ii/&#34;&gt;http://oj.leetcode.com/problems/single-number-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/candy/&#34;&gt;http://oj.leetcode.com/problems/candy/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/gas-station/&#34;&gt;http://oj.leetcode.com/problems/gas-station/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;动态规划:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;动态规划：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/triangle/&#34;&gt;http://oj.leetcode.com/problems/triangle/&lt;/a&gt;
（最短路径）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/subsets/&#34;&gt;http://oj.leetcode.com/problems/subsets/&lt;/a&gt;
（另一种形式）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/subsets-ii/&#34;&gt;http://oj.leetcode.com/problems/subsets-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/edit-distance/&#34;&gt;http://oj.leetcode.com/problems/edit-distance/&lt;/a&gt;
（经典）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/word-break/&#34;&gt;http://oj.leetcode.com/problems/word-break/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/word-break-ii/&#34;&gt;http://oj.leetcode.com/problems/word-break-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/unique-binary-search-trees/&#34;&gt;http://oj.leetcode.com/problems/unique-binary-search-trees/&lt;/a&gt;
（动态规划避免递归）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/unique-paths-ii/&#34;&gt;http://oj.leetcode.com/problems/unique-paths-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/scramble-string/&#34;&gt;http://oj.leetcode.com/problems/scramble-string/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/palindrome-partitioning/&#34;&gt;http://oj.leetcode.com/problems/palindrome-partitioning/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/palindrome-partitioning-ii/&#34;&gt;http://oj.leetcode.com/problems/palindrome-partitioning-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/interleaving-string/&#34;&gt;http://oj.leetcode.com/problems/interleaving-string/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/distinct-subsequences/&#34;&gt;http://oj.leetcode.com/problems/distinct-subsequences/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/decode-ways/&#34;&gt;http://oj.leetcode.com/problems/decode-ways/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/gray-code/&#34;&gt;http://oj.leetcode.com/problems/gray-code/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/minimum-path-sum/&#34;&gt;http://oj.leetcode.com/problems/minimum-path-sum/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;回溯:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;回溯：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/combinations/&#34;&gt;http://oj.leetcode.com/problems/combinations/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/generate-parentheses/&#34;&gt;http://oj.leetcode.com/problems/generate-parentheses/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/combination-sum/&#34;&gt;http://oj.leetcode.com/problems/combination-sum/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/combination-sum-ii/&#34;&gt;http://oj.leetcode.com/problems/combination-sum-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/sudoku-solver/&#34;&gt;http://oj.leetcode.com/problems/sudoku-solver/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;经典N皇后：&lt;a href=&#34;http://oj.leetcode.com/problems/n-queens/&#34;&gt;http://oj.leetcode.com/problems/n-queens/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/n-queens-ii/&#34;&gt;http://oj.leetcode.com/problems/n-queens-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/&#34;&gt;http://oj.leetcode.com/problems/letter-combinations-of-a-phone-number/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;贪心:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;贪心：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/&#34;&gt;http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/jump-game/&#34;&gt;http://oj.leetcode.com/problems/jump-game/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/jump-game-ii/&#34;&gt;http://oj.leetcode.com/problems/jump-game-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&#34;&gt;http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&#34;&gt;http://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/maximum-subarray/&#34;&gt;http://oj.leetcode.com/problems/maximum-subarray/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/minimum-window-substring/&#34;&gt;http://oj.leetcode.com/problems/minimum-window-substring/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/maximal-rectangle/&#34;&gt;http://oj.leetcode.com/problems/maximal-rectangle/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/&#34;&gt;http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;分治-递归:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;分治 &amp;amp; 递归：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/unique-binary-search-trees-ii/&#34;&gt;http://oj.leetcode.com/problems/unique-binary-search-trees-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/restore-ip-addresses/&#34;&gt;http://oj.leetcode.com/problems/restore-ip-addresses/&lt;/a&gt;
（时间复杂度有限，递归满足）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/permutations/&#34;&gt;http://oj.leetcode.com/problems/permutations/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/permutations-ii/&#34;&gt;http://oj.leetcode.com/problems/permutations-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/&#34;&gt;http://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/&#34;&gt;http://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/median-of-two-sorted-arrays/&#34;&gt;http://oj.leetcode.com/problems/median-of-two-sorted-arrays/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/validate-binary-search-tree/&#34;&gt;http://oj.leetcode.com/problems/validate-binary-search-tree/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;字符串:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;字符串：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/count-and-say/&#34;&gt;http://oj.leetcode.com/problems/count-and-say/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/implement-strstr/&#34;&gt;http://oj.leetcode.com/problems/implement-strstr/&lt;/a&gt;
（子串查找）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/anagrams/&#34;&gt;http://oj.leetcode.com/problems/anagrams/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/text-justification/&#34;&gt;http://oj.leetcode.com/problems/text-justification/&lt;/a&gt;
(细节）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/simplify-path/&#34;&gt;http://oj.leetcode.com/problems/simplify-path/&lt;/a&gt;
（基础控制语句 if-else-for）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/multiply-strings/&#34;&gt;http://oj.leetcode.com/problems/multiply-strings/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/regular-expression-matching/&#34;&gt;http://oj.leetcode.com/problems/regular-expression-matching/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/wildcard-matching/&#34;&gt;http://oj.leetcode.com/problems/wildcard-matching/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/longest-palindromic-substring/&#34;&gt;http://oj.leetcode.com/problems/longest-palindromic-substring/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/zigzag-conversion/&#34;&gt;http://oj.leetcode.com/problems/zigzag-conversion/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/length-of-last-word/&#34;&gt;http://oj.leetcode.com/problems/length-of-last-word/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/valid-palindrome/&#34;&gt;http://oj.leetcode.com/problems/valid-palindrome/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;图:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;图：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;深搜/广搜：&lt;a href=&#34;http://oj.leetcode.com/problems/clone-graph/&#34;&gt;http://oj.leetcode.com/problems/clone-graph/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;搜索-遍历:5831b95d540a7954e9cd64ed45727d7b&#34;&gt;搜索 &amp;amp; 遍历：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/word-ladder/&#34;&gt;http://oj.leetcode.com/problems/word-ladder/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oj.leetcode.com/problems/word-ladder-ii/&#34;&gt;http://oj.leetcode.com/problems/word-ladder-ii/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;广搜：&lt;a href=&#34;http://oj.leetcode.com/problems/surrounded-regions/&#34;&gt;http://oj.leetcode.com/problems/surrounded-regions/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode主题整理(4)链表及相关问题</title>
      <link>http://blog.ywheel.cn/post/2015/03/11/leetcode_linked_list/</link>
      <pubDate>Wed, 11 Mar 2015 01:32:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/11/leetcode_linked_list/</guid>
      <description>

&lt;pre&gt;&lt;code&gt;转载自：http://blog.csdn.net/feliciafay/article/details/18944093
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;topic-1-反转链表:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Topic 1 反转链表&lt;/h3&gt;

&lt;h4 id=&#34;reverse-linked-list-ii:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Reverse Linked List II&lt;/h4&gt;

&lt;p&gt;在第m~n个节点中反转单链表，注意这道题可以把代码写得很长，如果分为区间一[0,m-1],区间二[m-n],区间三[n+1,end]这三个区间的话。也可以写得很短，如果仔细观察发现其实只需要考虑第一个区间是否为NULL就可以了。&lt;/p&gt;

&lt;h4 id=&#34;reverse-nodes-in-k-group:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Reverse Nodes in K Group&lt;/h4&gt;

&lt;p&gt;每K个节点为一个单位，反转第1个单位之后，反转第2个单位，反转第i个单位，反转最后一个单位，如果最后一个单位不足K个，就不进行反转。非常有意思的一道题目，依然可以写得很短，也可以写得很长。如果你用递归的办法去写，可以很快写完。如果你用迭代的办法去写，都会比较长。不管是否是调用了Reverse Linked List II中的函数，或者直接写一个大循环。&lt;/p&gt;

&lt;h4 id=&#34;reorder-list:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Reorder List&lt;/h4&gt;

&lt;p&gt;仔细观察后，发现本题的规律是，把链表后半段反转，然后依次插入到链表的前半段。&lt;/p&gt;

&lt;h4 id=&#34;rotate-list:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Rotate List&lt;/h4&gt;

&lt;p&gt;旋转链表。&lt;/p&gt;

&lt;h3 id=&#34;topic-2-从数组排序迁移到链表排序:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Topic 2 从数组排序迁移到链表排序&lt;/h3&gt;

&lt;h4 id=&#34;insertion-sort-list:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Insertion Sort List&lt;/h4&gt;

&lt;p&gt;用链表来模拟插入排序&lt;/p&gt;

&lt;h4 id=&#34;partition:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Partition&lt;/h4&gt;

&lt;p&gt;用链表来模拟快排中的partition&lt;/p&gt;

&lt;h4 id=&#34;sort-list:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Sort List&lt;/h4&gt;

&lt;p&gt;用链表来进行归并排序，完成时间复杂度为O(N lgN),空间复杂度为O(1)的排序&lt;/p&gt;

&lt;h4 id=&#34;merge-two-sorted-lists:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Merge Two Sorted Lists&lt;/h4&gt;

&lt;p&gt;归并两个已经排好序的链表&lt;/p&gt;

&lt;h4 id=&#34;merge-k-sorted-lists:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Merge K Sorted Lists&lt;/h4&gt;

&lt;p&gt;归并K个已经排好序的链表&lt;/p&gt;

&lt;h3 id=&#34;topic-3-环形链表:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Topic 3 环形链表&lt;/h3&gt;

&lt;h4 id=&#34;linked-list-cycle:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Linked List Cycle&lt;/h4&gt;

&lt;p&gt;判断一个链表是否有环&lt;/p&gt;

&lt;h4 id=&#34;linked-list-cycle-ii:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Linked List Cycle II&lt;/h4&gt;

&lt;p&gt;如果一个链表有环，找到环的起始位置&lt;/p&gt;

&lt;h3 id=&#34;topic-4-其它问题:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Topic 4 其它问题&lt;/h3&gt;

&lt;h4 id=&#34;copy-list-with-random-pointer:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Copy List with Random Pointer&lt;/h4&gt;

&lt;p&gt;拷贝链表，链表的节点除了有next指针，还有random指针，指向任意一个点。&lt;/p&gt;

&lt;h4 id=&#34;remove-nth-node-from-end-of-list:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Remove Nth Node From End of List&lt;/h4&gt;

&lt;p&gt;删除从后向前数的第N个节点&lt;/p&gt;

&lt;h4 id=&#34;remove-duplicates-from-sorted-list:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Remove Duplicates from Sorted List&lt;/h4&gt;

&lt;p&gt;去掉链表中的重复元素，使得原来链表中的所有元素都出现并且只出现一次。&lt;/p&gt;

&lt;h4 id=&#34;remove-duplicates-from-sorted-list-ii:ac6eb2e8e47254236eacd8079d974b95&#34;&gt;Remove Duplicates from Sorted List II&lt;/h4&gt;

&lt;p&gt;去掉链表中的重复元素，使得原来链表中的非重复元素都出现并且只出现一次，重复元素不出现。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 066 Plus one</title>
      <link>http://blog.ywheel.cn/post/2015/03/11/leetcode_66/</link>
      <pubDate>Wed, 11 Mar 2015 01:26:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/11/leetcode_66/</guid>
      <description>&lt;p&gt;题目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://leetcode.com/problems/plus-one/
Given a non-negative number represented as an array of digits, plus one to the number.

The digits are stored such that the most significant digit is at the head of the list.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;题目虽简单，但是要注意的是当最高位是9的时候， 需要重新new一个长一位的新数组来存储结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {  
    public int[] plusOne(int[] digits) {  
        if (digits == null || digits.length == 0) return digits;  
        int carry = 1;  
        for (int i=digits.length - 1; i &amp;gt;= 0; i--) {  
            digits[i] = digits[i] + carry;  
            if (digits[i] &amp;lt; 10) {  
                return digits;  
            } else {  
                digits[i] = 0;  
                carry = 1;  
            }  
        }  
        int[] newDigits = new int[digits.length + 1];  
        newDigits[0] = 1;  
        System.arraycopy(digits, 0, newDigits, 1, digits.length);  
        return newDigits;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 33 Search in Rotated Sorted Array 二叉查找（三）</title>
      <link>http://blog.ywheel.cn/post/2015/03/10/leetcode_33/</link>
      <pubDate>Tue, 10 Mar 2015 01:45:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/10/leetcode_33/</guid>
      <description>&lt;p&gt;题目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://leetcode.com/problems/search-in-rotated-sorted-array/
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想当年校招的时候做过这一题，而且不是写在纸上的。故事是这样的。。。。（以上省略1万字，大意就是面试官拿着他的Thinkpad扔给了我问会写JAVA吗？会用eclipse吗？好，打开eclipse写吧，于是乎我就开始写，自己造了几个case都pass了，面试官一看总感觉哪里不对，狂试好几个，终于试出来个bug）
两年过去了，现在我正拿着该公司的macbook pro重新练习着这道题。。。依然写了几遍才过。。。哎&lt;/p&gt;

&lt;p&gt;又说多了，大概解法就是需要找到有序的一半是在哪里，找到了之后就看target是否在有序的那一半的范围内：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {  
    public int search(int[] A, int target) {  
        if (A == null || A.length == 0) {  
            return -1;  
        }  
        int l = 0;  
        int r = A.length - 1;  
        while (l &amp;lt;= r) {  
            int mid = (l + r) / 2;  
            if (A[mid] == target) {  
                return mid;  
            } else if (A[mid] &amp;lt; A[r]) {  
                // right side is sorted  
                if (target &amp;gt;= A[mid] &amp;amp;&amp;amp; target &amp;lt;= A[r]) {  
                    l = mid + 1;  
                } else {  
                    r = mid - 1;  
                }  
            } else {  
                // left side is sorted  
                if (target &amp;gt;= A[l] &amp;amp;&amp;amp; target &amp;lt;= A[mid]) {  
                    r = mid - 1;  
                } else {  
                    l = mid + 1;  
                }  
            }  
        }  
        return -1;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 34 Search For A Range 二叉查找相关（二）</title>
      <link>http://blog.ywheel.cn/post/2015/03/10/leetcode_34/</link>
      <pubDate>Tue, 10 Mar 2015 00:07:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/10/leetcode_34/</guid>
      <description>&lt;p&gt;题目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://leetcode.com/problems/search-for-a-range/
Given a sorted array of integers, find the starting and ending position of a given target value.

Your algorithm&#39;s runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

For example,
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最直接的想法就是先二叉查找到target的一个index，然后再往左往右分别查找边界，这样实际上有三遍二叉查找，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {  
    public int[] searchRange(int[] A, int target) {  
        int[] result = {-1, -1};  
        if (A == null || A.length == 0) {  
            return result;  
        }  
        int l = 0;  
        int r = A.length - 1;  
        boolean hasTarget = false;  
        int mid = (l + r) / 2;  
        while (l &amp;lt;= r) {  
            mid = (l + r) / 2;  
            if (A[mid] == target) {  
                hasTarget = true;  
                break;  
            } else if (A[mid] &amp;lt; target) {  
                l = mid + 1;  
            } else {  
                r = mid -1;  
            }  
        }  
        if (!hasTarget) {  
            return result;  
        }  
        // at this point, A[mid] = target, then need to find the range  
        // 1. find left range  
        l = 0;  
        r = mid;  
        result[1] = mid;  
        while (l &amp;lt;= r) {  
            mid = (l + r) / 2;  
            if (A[mid] == target) {  
                r = mid - 1;  
            } else {  
                // must be less than target  
                l = mid + 1;  
            }  
        }  
        result[0] = l;  
        // 2. find right range  
        l = result[1];  
        r = A.length - 1;  
        while (l &amp;lt;= r) {  
            mid = (l + r) / 2;  
            if (A[mid] == target) {  
                l = mid + 1;  
            } else {  
                // must be great than target  
                r = mid - 1;  
            }  
        }  
        result[1] = r;  
          
        return result;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提交之后发现运行时间排在JAVA类的靠后，有没有优化的空间呢？
发现其实并不需要先找到一个Index之后再找左右的边界，可以一遍二叉查找左边界，再来一次查找右边界，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {  
    public int[] searchRange(int[] A, int target) {  
        int[] result = {-1, -1};  
        if (A == null || A.length == 0) {  
            return result;  
        }  
        int l = 0;  
        int r = A.length - 1;  
        // 1. find left range  
        while (l &amp;lt;= r) {  
            int mid = (l + r) / 2;  
            if (A[mid] &amp;gt;= target) {  
                r = mid - 1;  
            } else {  
                l = mid + 1;  
            }  
        }  
        if (l &amp;gt;= A.length || A[l] != target) {  
            // not found  
            return result;  
        }  
        result[0] = l;  
        // 2. find right range  
        r = A.length - 1;  
        while (l &amp;lt;= r) {  
            int mid = (l + r) / 2;  
            if (A[mid] == target) {  
                l = mid + 1;  
            } else {  
                // must be great than target  
                r = mid - 1;  
            }  
        }  
        result[1] = r;  
          
        return result;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 35 Search Insert Position 二叉查找相关（一）</title>
      <link>http://blog.ywheel.cn/post/2015/03/09/leetcode_35/</link>
      <pubDate>Mon, 09 Mar 2015 23:41:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/09/leetcode_35/</guid>
      <description>&lt;p&gt;题目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://leetcode.com/problems/search-insert-position/
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Here are few examples.
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考查基本的二叉查找算法，直接上代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {  
    public int searchInsert(int[] A, int target) {  
        if (A == null || A.length == 0) {  
            return 0;  
        }  
        int l = 0;  
        int r = A.length - 1;  
        while (l &amp;lt;= r) {  
            int mid = (l + r) / 2;  
            if (A[mid] == target) {  
                return mid;  
            } else if (A[mid] &amp;lt; target) {  
                l = mid + 1;  
            } else {  
                r = mid -1;  
            }  
        }  
        return l;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 22 Generate Parentheses</title>
      <link>http://blog.ywheel.cn/post/2015/03/08/leetcode_22/</link>
      <pubDate>Sun, 08 Mar 2015 23:55:08 +0800</pubDate>
      
      <guid>http://blog.ywheel.cn/post/2015/03/08/leetcode_22/</guid>
      <description>&lt;p&gt;连续两次随机到关于括号的题了，跟括号真有缘。。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package ywheel.leetcode._22_generate_parentheses;  
  
import java.util.ArrayList;  
import java.util.List;  
  
/** 
 * Given n pairs of parentheses, write a function to generate all combinations 
 * of well-formed parentheses. 
 *  
 * For example, given n = 3, a solution set is: 
 * &amp;quot;((()))&amp;quot;, &amp;quot;(()())&amp;quot;, &amp;quot;(())()&amp;quot;, &amp;quot;()(())&amp;quot;, &amp;quot;()()()&amp;quot; 
 *  
 * @author ywheel 
 *  
 */  
public class GenerateParentheses {  
    public List&amp;lt;String&amp;gt; generateParenthesis(int n) {  
        List&amp;lt;String&amp;gt; results = new ArrayList&amp;lt;String&amp;gt;();  
        if (n &amp;gt; 0) {  
            // the first one must be &#39;(&#39;  
            generateNext(n, n - 1, &amp;quot;(&amp;quot;, results);  
        }  
        return results;  
    }  
    private void generateNext(int n, int rest_num_left, String solution, List&amp;lt;String&amp;gt; results) {  
        if (rest_num_left &amp;gt; 0) {  
            // can append &#39;(&#39;  
            generateNext(n, rest_num_left - 1, solution + &amp;quot;(&amp;quot;, results);  
            if (solution.length() &amp;lt; (n - rest_num_left)*2) {  
                // can append &#39;)&#39;  
                generateNext(n, rest_num_left, solution + &amp;quot;)&amp;quot;, results);  
            }  
        } else {  
            // has already append n &#39;(&#39;, so the only one solution here  
            // is to append all the rest &#39;)&#39;                  
            int rest_len = n*2 - solution.length();  
            while (rest_len &amp;gt; 0) {  
                solution += &amp;quot;)&amp;quot;;  
                rest_len--;  
            }  
            results.add(solution);  
        }  
    }  
      
    public static void main(String[] args) {  
        GenerateParentheses solution = new GenerateParentheses();  
        List&amp;lt;String&amp;gt; result = solution.generateParenthesis(3);  
        if (result != null) {  
            for (String str : result) {  
                System.out.print(str + &amp;quot;,&amp;quot;);  
            }  
        }  
    }  
}  

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>